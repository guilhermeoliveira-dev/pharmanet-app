{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar invariant = require(\"./invariant\");\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nvar traverseAllChildrenImpl = function (children, nameSoFar, indexSoFar, callback, traverseContext) {\n  var nextName, nextIndex;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);\n      nextIndex = indexSoFar + subtreeCount;\n      subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n    }\n  } else {\n    var type = typeof children;\n    var isOnlyChild = nameSoFar === '';\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows\n    var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;\n    if (children == null || type === 'boolean') {\n      // All of the above are perceived as null.\n      callback(traverseContext, null, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else if (type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {\n      callback(traverseContext, children, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else if (type === 'object') {\n      \"production\" !== process.env.NODE_ENV ? invariant(!children || children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(!children || children.nodeType !== 1);\n      for (var key in children) {\n        if (children.hasOwnProperty(key)) {\n          nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0);\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(children[key], nextName, nextIndex, callback, traverseContext);\n        }\n      }\n    }\n  }\n  return subtreeCount;\n};\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\nmodule.exports = traverseAllChildren;","map":{"version":3,"names":["ReactElement","require","ReactInstanceHandles","invariant","SEPARATOR","SUBSEPARATOR","userProvidedKeyEscaperLookup","userProvidedKeyEscapeRegex","userProvidedKeyEscaper","match","getComponentKey","component","index","key","wrapUserProvidedKey","toString","escapeUserProvidedKey","text","replace","traverseAllChildrenImpl","children","nameSoFar","indexSoFar","callback","traverseContext","nextName","nextIndex","subtreeCount","Array","isArray","i","length","child","type","isOnlyChild","storageName","isValidElement","process","env","NODE_ENV","nodeType","hasOwnProperty","traverseAllChildren","module","exports"],"sources":["/home/guilherme/Faculdade/LP2/Projeto_Farmacia/projeto-farmacia-app/node_modules/react-checkbox/node_modules/react/lib/traverseAllChildren.js"],"sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\n\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(\n    userProvidedKeyEscapeRegex,\n    userProvidedKeyEscaper\n  );\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nvar traverseAllChildrenImpl =\n  function(children, nameSoFar, indexSoFar, callback, traverseContext) {\n    var nextName, nextIndex;\n    var subtreeCount = 0;  // Count of children found in the current subtree.\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        nextName = (\n          nameSoFar +\n          (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n          getComponentKey(child, i)\n        );\n        nextIndex = indexSoFar + subtreeCount;\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          nextIndex,\n          callback,\n          traverseContext\n        );\n      }\n    } else {\n      var type = typeof children;\n      var isOnlyChild = nameSoFar === '';\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows\n      var storageName =\n        isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;\n      if (children == null || type === 'boolean') {\n        // All of the above are perceived as null.\n        callback(traverseContext, null, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (type === 'string' || type === 'number' ||\n                 ReactElement.isValidElement(children)) {\n        callback(traverseContext, children, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (type === 'object') {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !children || children.nodeType !== 1,\n          'traverseAllChildren(...): Encountered an invalid child; DOM ' +\n          'elements are not valid children of React components.'\n        ) : invariant(!children || children.nodeType !== 1));\n        for (var key in children) {\n          if (children.hasOwnProperty(key)) {\n            nextName = (\n              nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n              wrapUserProvidedKey(key) + SUBSEPARATOR +\n              getComponentKey(children[key], 0)\n            );\n            nextIndex = indexSoFar + subtreeCount;\n            subtreeCount += traverseAllChildrenImpl(\n              children[key],\n              nextName,\n              nextIndex,\n              callback,\n              traverseContext\n            );\n          }\n        }\n      }\n    }\n    return subtreeCount;\n  };\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}