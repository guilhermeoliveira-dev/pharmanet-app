{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponent\n */\n\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\nvar ReactOwner = require(\"./ReactOwner\");\nvar ReactUpdates = require(\"./ReactUpdates\");\nvar assign = require(\"./Object.assign\");\nvar invariant = require(\"./invariant\");\nvar keyMirror = require(\"./keyMirror\");\n\n/**\n * Every React component is in one of these life cycles.\n */\nvar ComponentLifeCycle = keyMirror({\n  /**\n   * Mounted components have a DOM node representation and are capable of\n   * receiving new props.\n   */\n  MOUNTED: null,\n  /**\n   * Unmounted components are inactive and cannot receive new props.\n   */\n  UNMOUNTED: null\n});\nvar injected = false;\n\n/**\n * Optionally injectable environment dependent cleanup hook. (server vs.\n * browser etc). Example: A browser system caches DOM nodes based on component\n * ID and must remove that cache entry when this instance is unmounted.\n *\n * @private\n */\nvar unmountIDFromEnvironment = null;\n\n/**\n * The \"image\" of a component tree, is the platform specific (typically\n * serialized) data that represents a tree of lower level UI building blocks.\n * On the web, this \"image\" is HTML markup which describes a construction of\n * low level `div` and `span` nodes. Other platforms may have different\n * encoding of this \"image\". This must be injected.\n *\n * @private\n */\nvar mountImageIntoNode = null;\n\n/**\n * Components are the basic units of composition in React.\n *\n * Every component accepts a set of keyed input parameters known as \"props\" that\n * are initialized by the constructor. Once a component is mounted, the props\n * can be mutated using `setProps` or `replaceProps`.\n *\n * Every component is capable of the following operations:\n *\n *   `mountComponent`\n *     Initializes the component, renders markup, and registers event listeners.\n *\n *   `receiveComponent`\n *     Updates the rendered DOM nodes to match the given component.\n *\n *   `unmountComponent`\n *     Releases any resources allocated by this component.\n *\n * Components can also be \"owned\" by other components. Being owned by another\n * component means being constructed by that component. This is different from\n * being the child of a component, which means having a DOM representation that\n * is a child of the DOM representation of that component.\n *\n * @class ReactComponent\n */\nvar ReactComponent = {\n  injection: {\n    injectEnvironment: function (ReactComponentEnvironment) {\n      \"production\" !== process.env.NODE_ENV ? invariant(!injected, 'ReactComponent: injectEnvironment() can only be called once.') : invariant(!injected);\n      mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;\n      unmountIDFromEnvironment = ReactComponentEnvironment.unmountIDFromEnvironment;\n      ReactComponent.BackendIDOperations = ReactComponentEnvironment.BackendIDOperations;\n      injected = true;\n    }\n  },\n  /**\n   * @internal\n   */\n  LifeCycle: ComponentLifeCycle,\n  /**\n   * Injected module that provides ability to mutate individual properties.\n   * Injected into the base class because many different subclasses need access\n   * to this.\n   *\n   * @internal\n   */\n  BackendIDOperations: null,\n  /**\n   * Base functionality for every ReactComponent constructor. Mixed into the\n   * `ReactComponent` prototype, but exposed statically for easy access.\n   *\n   * @lends {ReactComponent.prototype}\n   */\n  Mixin: {\n    /**\n     * Checks whether or not this component is mounted.\n     *\n     * @return {boolean} True if mounted, false otherwise.\n     * @final\n     * @protected\n     */\n    isMounted: function () {\n      return this._lifeCycleState === ComponentLifeCycle.MOUNTED;\n    },\n    /**\n     * Sets a subset of the props.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    setProps: function (partialProps, callback) {\n      // Merge with the pending element if it exists, otherwise with existing\n      // element props.\n      var element = this._pendingElement || this._currentElement;\n      this.replaceProps(assign({}, element.props, partialProps), callback);\n    },\n    /**\n     * Replaces all of the props.\n     *\n     * @param {object} props New props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    replaceProps: function (props, callback) {\n      \"production\" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'replaceProps(...): Can only update a mounted component.') : invariant(this.isMounted());\n      \"production\" !== process.env.NODE_ENV ? invariant(this._mountDepth === 0, 'replaceProps(...): You called `setProps` or `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(this._mountDepth === 0);\n      // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n      this._pendingElement = ReactElement.cloneAndReplaceProps(this._pendingElement || this._currentElement, props);\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n    /**\n     * Schedule a partial update to the props. Only used for internal testing.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @internal\n     */\n    _setPropsInternal: function (partialProps, callback) {\n      // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n      var element = this._pendingElement || this._currentElement;\n      this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n    /**\n     * Base constructor for all React components.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.construct.call(this, ...)`.\n     *\n     * @param {ReactElement} element\n     * @internal\n     */\n    construct: function (element) {\n      // This is the public exposed props object after it has been processed\n      // with default props. The element's props represents the true internal\n      // state of the props.\n      this.props = element.props;\n      // Record the component responsible for creating this component.\n      // This is accessible through the element but we maintain an extra\n      // field for compatibility with devtools and as a way to make an\n      // incremental update. TODO: Consider deprecating this field.\n      this._owner = element._owner;\n\n      // All components start unmounted.\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;\n\n      // See ReactUpdates.\n      this._pendingCallbacks = null;\n\n      // We keep the old element and a reference to the pending element\n      // to track updates.\n      this._currentElement = element;\n      this._pendingElement = null;\n    },\n    /**\n     * Initializes the component, renders markup, and registers event listeners.\n     *\n     * NOTE: This does not insert any nodes into the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.mountComponent.call(this, ...)`.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n     * @param {number} mountDepth number of components in the owner hierarchy.\n     * @return {?string} Rendered markup to be inserted into the DOM.\n     * @internal\n     */\n    mountComponent: function (rootID, transaction, mountDepth) {\n      \"production\" !== process.env.NODE_ENV ? invariant(!this.isMounted(), 'mountComponent(%s, ...): Can only mount an unmounted component. ' + 'Make sure to avoid storing components between renders or reusing a ' + 'single component instance in multiple places.', rootID) : invariant(!this.isMounted());\n      var ref = this._currentElement.ref;\n      if (ref != null) {\n        var owner = this._currentElement._owner;\n        ReactOwner.addComponentAsRefTo(this, ref, owner);\n      }\n      this._rootNodeID = rootID;\n      this._lifeCycleState = ComponentLifeCycle.MOUNTED;\n      this._mountDepth = mountDepth;\n      // Effectively: return '';\n    },\n    /**\n     * Releases any resources allocated by `mountComponent`.\n     *\n     * NOTE: This does not remove any nodes from the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.unmountComponent.call(this)`.\n     *\n     * @internal\n     */\n    unmountComponent: function () {\n      \"production\" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'unmountComponent(): Can only unmount a mounted component.') : invariant(this.isMounted());\n      var ref = this._currentElement.ref;\n      if (ref != null) {\n        ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);\n      }\n      unmountIDFromEnvironment(this._rootNodeID);\n      this._rootNodeID = null;\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;\n    },\n    /**\n     * Given a new instance of this component, updates the rendered DOM nodes\n     * as if that instance was rendered instead.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.\n     *\n     * @param {object} nextComponent Next set of properties.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    receiveComponent: function (nextElement, transaction) {\n      \"production\" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'receiveComponent(...): Can only update a mounted component.') : invariant(this.isMounted());\n      this._pendingElement = nextElement;\n      this.performUpdateIfNecessary(transaction);\n    },\n    /**\n     * If `_pendingElement` is set, update the component.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    performUpdateIfNecessary: function (transaction) {\n      if (this._pendingElement == null) {\n        return;\n      }\n      var prevElement = this._currentElement;\n      var nextElement = this._pendingElement;\n      this._currentElement = nextElement;\n      this.props = nextElement.props;\n      this._owner = nextElement._owner;\n      this._pendingElement = null;\n      this.updateComponent(transaction, prevElement);\n    },\n    /**\n     * Updates the component's currently mounted representation.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @param {object} prevElement\n     * @internal\n     */\n    updateComponent: function (transaction, prevElement) {\n      var nextElement = this._currentElement;\n\n      // If either the owner or a `ref` has changed, make sure the newest owner\n      // has stored a reference to `this`, and the previous owner (if different)\n      // has forgotten the reference to `this`. We use the element instead\n      // of the public this.props because the post processing cannot determine\n      // a ref. The ref conceptually lives on the element.\n\n      // TODO: Should this even be possible? The owner cannot change because\n      // it's forbidden by shouldUpdateReactComponent. The ref can change\n      // if you swap the keys of but not the refs. Reconsider where this check\n      // is made. It probably belongs where the key checking and\n      // instantiateReactComponent is done.\n\n      if (nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref) {\n        if (prevElement.ref != null) {\n          ReactOwner.removeComponentAsRefFrom(this, prevElement.ref, prevElement._owner);\n        }\n        // Correct, even if the owner is the same, and only the ref has changed.\n        if (nextElement.ref != null) {\n          ReactOwner.addComponentAsRefTo(this, nextElement.ref, nextElement._owner);\n        }\n      }\n    },\n    /**\n     * Mounts this component and inserts it into the DOM.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @internal\n     * @see {ReactMount.render}\n     */\n    mountComponentIntoNode: function (rootID, container, shouldReuseMarkup) {\n      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n      transaction.perform(this._mountComponentIntoNode, this, rootID, container, transaction, shouldReuseMarkup);\n      ReactUpdates.ReactReconcileTransaction.release(transaction);\n    },\n    /**\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {ReactReconcileTransaction} transaction\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @private\n     */\n    _mountComponentIntoNode: function (rootID, container, transaction, shouldReuseMarkup) {\n      var markup = this.mountComponent(rootID, transaction, 0);\n      mountImageIntoNode(markup, container, shouldReuseMarkup);\n    },\n    /**\n     * Checks if this component is owned by the supplied `owner` component.\n     *\n     * @param {ReactComponent} owner Component to check.\n     * @return {boolean} True if `owners` owns this component.\n     * @final\n     * @internal\n     */\n    isOwnedBy: function (owner) {\n      return this._owner === owner;\n    },\n    /**\n     * Gets another component, that shares the same owner as this one, by ref.\n     *\n     * @param {string} ref of a sibling Component.\n     * @return {?ReactComponent} the actual sibling Component.\n     * @final\n     * @internal\n     */\n    getSiblingByRef: function (ref) {\n      var owner = this._owner;\n      if (!owner || !owner.refs) {\n        return null;\n      }\n      return owner.refs[ref];\n    }\n  }\n};\nmodule.exports = ReactComponent;","map":{"version":3,"names":["ReactElement","require","ReactOwner","ReactUpdates","assign","invariant","keyMirror","ComponentLifeCycle","MOUNTED","UNMOUNTED","injected","unmountIDFromEnvironment","mountImageIntoNode","ReactComponent","injection","injectEnvironment","ReactComponentEnvironment","process","env","NODE_ENV","BackendIDOperations","LifeCycle","Mixin","isMounted","_lifeCycleState","setProps","partialProps","callback","element","_pendingElement","_currentElement","replaceProps","props","_mountDepth","cloneAndReplaceProps","enqueueUpdate","_setPropsInternal","construct","_owner","_pendingCallbacks","mountComponent","rootID","transaction","mountDepth","ref","owner","addComponentAsRefTo","_rootNodeID","unmountComponent","removeComponentAsRefFrom","receiveComponent","nextElement","performUpdateIfNecessary","prevElement","updateComponent","mountComponentIntoNode","container","shouldReuseMarkup","ReactReconcileTransaction","getPooled","perform","_mountComponentIntoNode","release","markup","isOwnedBy","getSiblingByRef","refs","module","exports"],"sources":["/home/guilherme/Faculdade/LP2/Projeto_Farmacia/projeto-farmacia-app/node_modules/react-checkbox/node_modules/react/lib/ReactComponent.js"],"sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponent\n */\n\n\"use strict\";\n\nvar ReactElement = require(\"./ReactElement\");\nvar ReactOwner = require(\"./ReactOwner\");\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\");\nvar invariant = require(\"./invariant\");\nvar keyMirror = require(\"./keyMirror\");\n\n/**\n * Every React component is in one of these life cycles.\n */\nvar ComponentLifeCycle = keyMirror({\n  /**\n   * Mounted components have a DOM node representation and are capable of\n   * receiving new props.\n   */\n  MOUNTED: null,\n  /**\n   * Unmounted components are inactive and cannot receive new props.\n   */\n  UNMOUNTED: null\n});\n\nvar injected = false;\n\n/**\n * Optionally injectable environment dependent cleanup hook. (server vs.\n * browser etc). Example: A browser system caches DOM nodes based on component\n * ID and must remove that cache entry when this instance is unmounted.\n *\n * @private\n */\nvar unmountIDFromEnvironment = null;\n\n/**\n * The \"image\" of a component tree, is the platform specific (typically\n * serialized) data that represents a tree of lower level UI building blocks.\n * On the web, this \"image\" is HTML markup which describes a construction of\n * low level `div` and `span` nodes. Other platforms may have different\n * encoding of this \"image\". This must be injected.\n *\n * @private\n */\nvar mountImageIntoNode = null;\n\n/**\n * Components are the basic units of composition in React.\n *\n * Every component accepts a set of keyed input parameters known as \"props\" that\n * are initialized by the constructor. Once a component is mounted, the props\n * can be mutated using `setProps` or `replaceProps`.\n *\n * Every component is capable of the following operations:\n *\n *   `mountComponent`\n *     Initializes the component, renders markup, and registers event listeners.\n *\n *   `receiveComponent`\n *     Updates the rendered DOM nodes to match the given component.\n *\n *   `unmountComponent`\n *     Releases any resources allocated by this component.\n *\n * Components can also be \"owned\" by other components. Being owned by another\n * component means being constructed by that component. This is different from\n * being the child of a component, which means having a DOM representation that\n * is a child of the DOM representation of that component.\n *\n * @class ReactComponent\n */\nvar ReactComponent = {\n\n  injection: {\n    injectEnvironment: function(ReactComponentEnvironment) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !injected,\n        'ReactComponent: injectEnvironment() can only be called once.'\n      ) : invariant(!injected));\n      mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;\n      unmountIDFromEnvironment =\n        ReactComponentEnvironment.unmountIDFromEnvironment;\n      ReactComponent.BackendIDOperations =\n        ReactComponentEnvironment.BackendIDOperations;\n      injected = true;\n    }\n  },\n\n  /**\n   * @internal\n   */\n  LifeCycle: ComponentLifeCycle,\n\n  /**\n   * Injected module that provides ability to mutate individual properties.\n   * Injected into the base class because many different subclasses need access\n   * to this.\n   *\n   * @internal\n   */\n  BackendIDOperations: null,\n\n  /**\n   * Base functionality for every ReactComponent constructor. Mixed into the\n   * `ReactComponent` prototype, but exposed statically for easy access.\n   *\n   * @lends {ReactComponent.prototype}\n   */\n  Mixin: {\n\n    /**\n     * Checks whether or not this component is mounted.\n     *\n     * @return {boolean} True if mounted, false otherwise.\n     * @final\n     * @protected\n     */\n    isMounted: function() {\n      return this._lifeCycleState === ComponentLifeCycle.MOUNTED;\n    },\n\n    /**\n     * Sets a subset of the props.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    setProps: function(partialProps, callback) {\n      // Merge with the pending element if it exists, otherwise with existing\n      // element props.\n      var element = this._pendingElement || this._currentElement;\n      this.replaceProps(\n        assign({}, element.props, partialProps),\n        callback\n      );\n    },\n\n    /**\n     * Replaces all of the props.\n     *\n     * @param {object} props New props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    replaceProps: function(props, callback) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this.isMounted(),\n        'replaceProps(...): Can only update a mounted component.'\n      ) : invariant(this.isMounted()));\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this._mountDepth === 0,\n        'replaceProps(...): You called `setProps` or `replaceProps` on a ' +\n        'component with a parent. This is an anti-pattern since props will ' +\n        'get reactively updated when rendered. Instead, change the owner\\'s ' +\n        '`render` method to pass the correct value as props to the component ' +\n        'where it is created.'\n      ) : invariant(this._mountDepth === 0));\n      // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n      this._pendingElement = ReactElement.cloneAndReplaceProps(\n        this._pendingElement || this._currentElement,\n        props\n      );\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n\n    /**\n     * Schedule a partial update to the props. Only used for internal testing.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @internal\n     */\n    _setPropsInternal: function(partialProps, callback) {\n      // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n      var element = this._pendingElement || this._currentElement;\n      this._pendingElement = ReactElement.cloneAndReplaceProps(\n        element,\n        assign({}, element.props, partialProps)\n      );\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n\n    /**\n     * Base constructor for all React components.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.construct.call(this, ...)`.\n     *\n     * @param {ReactElement} element\n     * @internal\n     */\n    construct: function(element) {\n      // This is the public exposed props object after it has been processed\n      // with default props. The element's props represents the true internal\n      // state of the props.\n      this.props = element.props;\n      // Record the component responsible for creating this component.\n      // This is accessible through the element but we maintain an extra\n      // field for compatibility with devtools and as a way to make an\n      // incremental update. TODO: Consider deprecating this field.\n      this._owner = element._owner;\n\n      // All components start unmounted.\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;\n\n      // See ReactUpdates.\n      this._pendingCallbacks = null;\n\n      // We keep the old element and a reference to the pending element\n      // to track updates.\n      this._currentElement = element;\n      this._pendingElement = null;\n    },\n\n    /**\n     * Initializes the component, renders markup, and registers event listeners.\n     *\n     * NOTE: This does not insert any nodes into the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.mountComponent.call(this, ...)`.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n     * @param {number} mountDepth number of components in the owner hierarchy.\n     * @return {?string} Rendered markup to be inserted into the DOM.\n     * @internal\n     */\n    mountComponent: function(rootID, transaction, mountDepth) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !this.isMounted(),\n        'mountComponent(%s, ...): Can only mount an unmounted component. ' +\n        'Make sure to avoid storing components between renders or reusing a ' +\n        'single component instance in multiple places.',\n        rootID\n      ) : invariant(!this.isMounted()));\n      var ref = this._currentElement.ref;\n      if (ref != null) {\n        var owner = this._currentElement._owner;\n        ReactOwner.addComponentAsRefTo(this, ref, owner);\n      }\n      this._rootNodeID = rootID;\n      this._lifeCycleState = ComponentLifeCycle.MOUNTED;\n      this._mountDepth = mountDepth;\n      // Effectively: return '';\n    },\n\n    /**\n     * Releases any resources allocated by `mountComponent`.\n     *\n     * NOTE: This does not remove any nodes from the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.unmountComponent.call(this)`.\n     *\n     * @internal\n     */\n    unmountComponent: function() {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this.isMounted(),\n        'unmountComponent(): Can only unmount a mounted component.'\n      ) : invariant(this.isMounted()));\n      var ref = this._currentElement.ref;\n      if (ref != null) {\n        ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);\n      }\n      unmountIDFromEnvironment(this._rootNodeID);\n      this._rootNodeID = null;\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;\n    },\n\n    /**\n     * Given a new instance of this component, updates the rendered DOM nodes\n     * as if that instance was rendered instead.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.\n     *\n     * @param {object} nextComponent Next set of properties.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    receiveComponent: function(nextElement, transaction) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this.isMounted(),\n        'receiveComponent(...): Can only update a mounted component.'\n      ) : invariant(this.isMounted()));\n      this._pendingElement = nextElement;\n      this.performUpdateIfNecessary(transaction);\n    },\n\n    /**\n     * If `_pendingElement` is set, update the component.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    performUpdateIfNecessary: function(transaction) {\n      if (this._pendingElement == null) {\n        return;\n      }\n      var prevElement = this._currentElement;\n      var nextElement = this._pendingElement;\n      this._currentElement = nextElement;\n      this.props = nextElement.props;\n      this._owner = nextElement._owner;\n      this._pendingElement = null;\n      this.updateComponent(transaction, prevElement);\n    },\n\n    /**\n     * Updates the component's currently mounted representation.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @param {object} prevElement\n     * @internal\n     */\n    updateComponent: function(transaction, prevElement) {\n      var nextElement = this._currentElement;\n\n      // If either the owner or a `ref` has changed, make sure the newest owner\n      // has stored a reference to `this`, and the previous owner (if different)\n      // has forgotten the reference to `this`. We use the element instead\n      // of the public this.props because the post processing cannot determine\n      // a ref. The ref conceptually lives on the element.\n\n      // TODO: Should this even be possible? The owner cannot change because\n      // it's forbidden by shouldUpdateReactComponent. The ref can change\n      // if you swap the keys of but not the refs. Reconsider where this check\n      // is made. It probably belongs where the key checking and\n      // instantiateReactComponent is done.\n\n      if (nextElement._owner !== prevElement._owner ||\n          nextElement.ref !== prevElement.ref) {\n        if (prevElement.ref != null) {\n          ReactOwner.removeComponentAsRefFrom(\n            this, prevElement.ref, prevElement._owner\n          );\n        }\n        // Correct, even if the owner is the same, and only the ref has changed.\n        if (nextElement.ref != null) {\n          ReactOwner.addComponentAsRefTo(\n            this,\n            nextElement.ref,\n            nextElement._owner\n          );\n        }\n      }\n    },\n\n    /**\n     * Mounts this component and inserts it into the DOM.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @internal\n     * @see {ReactMount.render}\n     */\n    mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {\n      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n      transaction.perform(\n        this._mountComponentIntoNode,\n        this,\n        rootID,\n        container,\n        transaction,\n        shouldReuseMarkup\n      );\n      ReactUpdates.ReactReconcileTransaction.release(transaction);\n    },\n\n    /**\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {ReactReconcileTransaction} transaction\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @private\n     */\n    _mountComponentIntoNode: function(\n        rootID,\n        container,\n        transaction,\n        shouldReuseMarkup) {\n      var markup = this.mountComponent(rootID, transaction, 0);\n      mountImageIntoNode(markup, container, shouldReuseMarkup);\n    },\n\n    /**\n     * Checks if this component is owned by the supplied `owner` component.\n     *\n     * @param {ReactComponent} owner Component to check.\n     * @return {boolean} True if `owners` owns this component.\n     * @final\n     * @internal\n     */\n    isOwnedBy: function(owner) {\n      return this._owner === owner;\n    },\n\n    /**\n     * Gets another component, that shares the same owner as this one, by ref.\n     *\n     * @param {string} ref of a sibling Component.\n     * @return {?ReactComponent} the actual sibling Component.\n     * @final\n     * @internal\n     */\n    getSiblingByRef: function(ref) {\n      var owner = this._owner;\n      if (!owner || !owner.refs) {\n        return null;\n      }\n      return owner.refs[ref];\n    }\n  }\n};\n\nmodule.exports = ReactComponent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}