{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPerf\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * ReactPerf is a general AOP system designed to measure performance. This\n * module only has the hooks: see ReactDefaultPerf for the analysis tool.\n */\nvar ReactPerf = {\n  /**\n   * Boolean to enable/disable measurement. Set to false by default to prevent\n   * accidental logging and perf loss.\n   */\n  enableMeasure: false,\n  /**\n   * Holds onto the measure function in use. By default, don't measure\n   * anything, but we'll override this if we inject a measure function.\n   */\n  storedMeasure: _noMeasure,\n  /**\n   * Use this to wrap methods you want to measure. Zero overhead in production.\n   *\n   * @param {string} objName\n   * @param {string} fnName\n   * @param {function} func\n   * @return {function}\n   */\n  measure: function (objName, fnName, func) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      var measuredFunc = null;\n      var wrapper = function () {\n        if (ReactPerf.enableMeasure) {\n          if (!measuredFunc) {\n            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);\n          }\n          return measuredFunc.apply(this, arguments);\n        }\n        return func.apply(this, arguments);\n      };\n      wrapper.displayName = objName + '_' + fnName;\n      return wrapper;\n    }\n    return func;\n  },\n  injection: {\n    /**\n     * @param {function} measure\n     */\n    injectMeasure: function (measure) {\n      ReactPerf.storedMeasure = measure;\n    }\n  }\n};\n\n/**\n * Simply passes through the measured function, without measuring it.\n *\n * @param {string} objName\n * @param {string} fnName\n * @param {function} func\n * @return {function}\n */\nfunction _noMeasure(objName, fnName, func) {\n  return func;\n}\nmodule.exports = ReactPerf;","map":{"version":3,"names":["ReactPerf","enableMeasure","storedMeasure","_noMeasure","measure","objName","fnName","func","process","env","NODE_ENV","measuredFunc","wrapper","apply","arguments","displayName","injection","injectMeasure","module","exports"],"sources":["/home/guilherme/Faculdade/LP2/Projeto_Farmacia/projeto-farmacia-app/node_modules/react-checkbox/node_modules/react/lib/ReactPerf.js"],"sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPerf\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * ReactPerf is a general AOP system designed to measure performance. This\n * module only has the hooks: see ReactDefaultPerf for the analysis tool.\n */\nvar ReactPerf = {\n  /**\n   * Boolean to enable/disable measurement. Set to false by default to prevent\n   * accidental logging and perf loss.\n   */\n  enableMeasure: false,\n\n  /**\n   * Holds onto the measure function in use. By default, don't measure\n   * anything, but we'll override this if we inject a measure function.\n   */\n  storedMeasure: _noMeasure,\n\n  /**\n   * Use this to wrap methods you want to measure. Zero overhead in production.\n   *\n   * @param {string} objName\n   * @param {string} fnName\n   * @param {function} func\n   * @return {function}\n   */\n  measure: function(objName, fnName, func) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      var measuredFunc = null;\n      var wrapper = function() {\n        if (ReactPerf.enableMeasure) {\n          if (!measuredFunc) {\n            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);\n          }\n          return measuredFunc.apply(this, arguments);\n        }\n        return func.apply(this, arguments);\n      };\n      wrapper.displayName = objName + '_' + fnName;\n      return wrapper;\n    }\n    return func;\n  },\n\n  injection: {\n    /**\n     * @param {function} measure\n     */\n    injectMeasure: function(measure) {\n      ReactPerf.storedMeasure = measure;\n    }\n  }\n};\n\n/**\n * Simply passes through the measured function, without measuring it.\n *\n * @param {string} objName\n * @param {string} fnName\n * @param {function} func\n * @return {function}\n */\nfunction _noMeasure(objName, fnName, func) {\n  return func;\n}\n\nmodule.exports = ReactPerf;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA,IAAIA,SAAS,GAAG;EACd;AACF;AACA;AACA;EACEC,aAAa,EAAE,KAAK;EAEpB;AACF;AACA;AACA;EACEC,aAAa,EAAEC,UAAU;EAEzB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAO,EAAE,SAAAA,CAASC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;IACvC,IAAI,YAAY,KAAKC,OAAO,CAACC,GAAG,CAACC,QAAQ,EAAE;MACzC,IAAIC,YAAY,GAAG,IAAI;MACvB,IAAIC,OAAO,GAAG,SAAAA,CAAA,EAAW;QACvB,IAAIZ,SAAS,CAACC,aAAa,EAAE;UAC3B,IAAI,CAACU,YAAY,EAAE;YACjBA,YAAY,GAAGX,SAAS,CAACE,aAAa,CAACG,OAAO,EAAEC,MAAM,EAAEC,IAAI,CAAC;UAC/D;UACA,OAAOI,YAAY,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;QAC5C;QACA,OAAOP,IAAI,CAACM,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MACpC,CAAC;MACDF,OAAO,CAACG,WAAW,GAAGV,OAAO,GAAG,GAAG,GAAGC,MAAM;MAC5C,OAAOM,OAAO;IAChB;IACA,OAAOL,IAAI;EACb,CAAC;EAEDS,SAAS,EAAE;IACT;AACJ;AACA;IACIC,aAAa,EAAE,SAAAA,CAASb,OAAO,EAAE;MAC/BJ,SAAS,CAACE,aAAa,GAAGE,OAAO;IACnC;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,UAAUA,CAACE,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACzC,OAAOA,IAAI;AACb;AAEAW,MAAM,CAACC,OAAO,GAAGnB,SAAS","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}