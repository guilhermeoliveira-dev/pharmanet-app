{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n\"use strict\";\n\nvar DOMProperty = require(\"./DOMProperty\");\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactLegacyElement = require(\"./ReactLegacyElement\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar containsNode = require(\"./containsNode\");\nvar deprecated = require(\"./deprecated\");\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar invariant = require(\"./invariant\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\nvar warning = require(\"./warning\");\nvar createElement = ReactLegacyElement.wrapCreateElement(ReactElement.createElement);\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        \"production\" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id));\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n  return id;\n}\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    \"production\" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id);\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounting is the process of initializing a React component by creatings its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextComponent, container, callback) {\n    var nextProps = nextComponent.props;\n    ReactMount.scrollMonitor(container, function () {\n      prevComponent.replaceProps(nextProps, callback);\n    });\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n    return prevComponent;\n  },\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: ReactPerf.measure('ReactMount', '_renderNewRootComponent', function (nextComponent, container, shouldReuseMarkup) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    var componentInstance = instantiateReactComponent(nextComponent, null);\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\n    componentInstance.mountComponentIntoNode(reactRootID, container, shouldReuseMarkup);\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n    return componentInstance;\n  }),\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'renderComponent(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : ReactLegacyElement.isValidFactory(nextElement) ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :\n    // Check if it quacks like a element\n    typeof nextElement.props !== \"undefined\" ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(ReactElement.isValidElement(nextElement));\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback);\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n    var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup);\n    callback && callback.call(component);\n    return component;\n  },\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function (constructor, props, container) {\n    var element = createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function (constructor, props, id) {\n    var domNode = document.getElementById(id);\n    \"production\" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of \"%s\" but it is not present on the page.', id) : invariant(domNode);\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function (instance, container) {\n    instance.unmountComponent();\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        \"production\" !== process.env.NODE_ENV ? invariant(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID);\n        var containerChild = container.firstChild;\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          console.warn('ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode);\n        }\n      }\n    }\n    return container;\n  },\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function (node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n        child = child.nextSibling;\n      }\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n        return targetChild;\n      }\n    }\n    firstChildren.length = 0;\n    \"production\" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false);\n  },\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n  getID: getID,\n  setID: setID,\n  getNode: getNode,\n  purgeID: purgeID\n};\n\n// Deprecations (remove for 0.13)\nReactMount.renderComponent = deprecated('ReactMount', 'renderComponent', 'render', this, ReactMount.render);\nmodule.exports = ReactMount;","map":{"version":3,"names":["DOMProperty","require","ReactBrowserEventEmitter","ReactCurrentOwner","ReactElement","ReactLegacyElement","ReactInstanceHandles","ReactPerf","containsNode","deprecated","getReactRootElementInContainer","instantiateReactComponent","invariant","shouldUpdateReactComponent","warning","createElement","wrapCreateElement","SEPARATOR","ATTR_NAME","ID_ATTRIBUTE_NAME","nodeCache","ELEMENT_NODE_TYPE","DOC_NODE_TYPE","instancesByReactRootID","containersByReactRootID","process","env","NODE_ENV","rootElementsByReactRootID","findComponentRootReusableArray","getReactRootID","container","rootElement","ReactMount","getID","node","id","internalGetID","hasOwnProperty","cached","isValid","getAttribute","setID","oldID","setAttribute","getNode","findReactNodeByID","findReactContainerForID","purgeID","deepestNodeSoFar","findDeepestCachedAncestorImpl","ancestorID","ancestor","findDeepestCachedAncestor","targetID","traverseAncestors","foundNode","_instancesByReactRootID","scrollMonitor","renderCallback","_updateRootComponent","prevComponent","nextComponent","callback","nextProps","props","replaceProps","_registerComponent","nodeType","ensureScrollValueMonitoring","reactRootID","registerContainer","_renderNewRootComponent","measure","shouldReuseMarkup","current","componentInstance","mountComponentIntoNode","render","nextElement","isValidElement","isValidFactory","prevElement","_currentElement","unmountComponentAtNode","reactRootElement","containerHasReactMarkup","isRenderedByReact","component","call","constructAndRenderComponent","constructor","element","constructAndRenderComponentByID","domNode","document","getElementById","getReactRootIDFromNodeID","createReactRootID","unmountComponentFromNode","instance","unmountComponent","documentElement","lastChild","removeChild","parentNode","containerChild","firstChild","console","warn","reactRoot","findComponentRoot","charAt","getFirstReactDOM","ancestorNode","firstChildren","childIndex","deepestAncestor","length","child","targetChild","childID","isAncestorIDOf","push","nextSibling","renderComponent","module","exports"],"sources":["/home/guilherme/Faculdade/LP2/Projeto_Farmacia/projeto-farmacia-app/node_modules/react-checkbox/node_modules/react/lib/ReactMount.js"],"sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n\"use strict\";\n\nvar DOMProperty = require(\"./DOMProperty\");\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactLegacyElement = require(\"./ReactLegacyElement\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactPerf = require(\"./ReactPerf\");\n\nvar containsNode = require(\"./containsNode\");\nvar deprecated = require(\"./deprecated\");\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar invariant = require(\"./invariant\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\nvar warning = require(\"./warning\");\n\nvar createElement = ReactLegacyElement.wrapCreateElement(\n  ReactElement.createElement\n);\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !isValid(cached, id),\n          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',\n          ATTR_NAME, id\n        ) : invariant(!isValid(cached, id)));\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      internalGetID(node) === id,\n      'ReactMount: Unexpected modification of `%s`',\n      ATTR_NAME\n    ) : invariant(internalGetID(node) === id));\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(\n    targetID,\n    findDeepestCachedAncestorImpl\n  );\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounting is the process of initializing a React component by creatings its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function(container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function(\n      prevComponent,\n      nextComponent,\n      container,\n      callback) {\n    var nextProps = nextComponent.props;\n    ReactMount.scrollMonitor(container, function() {\n      prevComponent.replaceProps(nextProps, callback);\n    });\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] =\n        getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function(nextComponent, container) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        container.nodeType === ELEMENT_NODE_TYPE ||\n        container.nodeType === DOC_NODE_TYPE\n      ),\n      '_registerComponent(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      container.nodeType === ELEMENT_NODE_TYPE ||\n      container.nodeType === DOC_NODE_TYPE\n    )));\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: ReactPerf.measure(\n    'ReactMount',\n    '_renderNewRootComponent',\n    function(\n        nextComponent,\n        container,\n        shouldReuseMarkup) {\n      // Various parts of our code (such as ReactCompositeComponent's\n      // _renderValidatedComponent) assume that calls to render aren't nested;\n      // verify that that's the case.\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        ReactCurrentOwner.current == null,\n        '_renderNewRootComponent(): Render methods should be a pure function ' +\n        'of props and state; triggering nested component updates from ' +\n        'render is not allowed. If necessary, trigger nested updates in ' +\n        'componentDidUpdate.'\n      ) : null);\n\n      var componentInstance = instantiateReactComponent(nextComponent, null);\n      var reactRootID = ReactMount._registerComponent(\n        componentInstance,\n        container\n      );\n      componentInstance.mountComponentIntoNode(\n        reactRootID,\n        container,\n        shouldReuseMarkup\n      );\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        // Record the root element in case it later gets transplanted.\n        rootElementsByReactRootID[reactRootID] =\n          getReactRootElementInContainer(container);\n      }\n\n      return componentInstance;\n    }\n  ),\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function(nextElement, container, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReactElement.isValidElement(nextElement),\n      'renderComponent(): Invalid component element.%s',\n      (\n        typeof nextElement === 'string' ?\n          ' Instead of passing an element string, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        ReactLegacyElement.isValidFactory(nextElement) ?\n          ' Instead of passing a component class, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        // Check if it quacks like a element\n        typeof nextElement.props !== \"undefined\" ?\n          ' This may be caused by unintentionally loading two independent ' +\n          'copies of React.' :\n          ''\n      )\n    ) : invariant(ReactElement.isValidElement(nextElement)));\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(\n          prevComponent,\n          nextElement,\n          container,\n          callback\n        );\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup =\n      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(\n      nextElement,\n      container,\n      shouldReuseMarkup\n    );\n    callback && callback.call(component);\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function(constructor, props, container) {\n    var element = createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function(constructor, props, id) {\n    var domNode = document.getElementById(id);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      domNode,\n      'Tried to get element with id of \"%s\" but it is not present on the page.',\n      id\n    ) : invariant(domNode));\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function(container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function(container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      ReactCurrentOwner.current == null,\n      'unmountComponentAtNode(): Render methods should be a pure function of ' +\n      'props and state; triggering nested component updates from render is ' +\n      'not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function(instance, container) {\n    instance.unmountComponent();\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function(id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          // Call internalGetID here because getID calls isValid which calls\n          // findReactContainerForID (this function).\n          internalGetID(rootElement) === reactRootID,\n          'ReactMount: Root element ID differed from reactRootID.'\n        ) : invariant(// Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID));\n\n        var containerChild = container.firstChild;\n        if (containerChild &&\n            reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          console.warn(\n            'ReactMount: Root element has been removed from its original ' +\n            'container. New container:', rootElement.parentNode\n          );\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function(id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function(node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function(node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function(ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      false,\n      'findComponentRoot(..., %s): Unable to find element. This probably ' +\n      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +\n      'usually due to forgetting a <tbody> when using tables, nesting tags ' +\n      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +\n      'parent. ' +\n      'Try inspecting the child nodes of the element with React ID `%s`.',\n      targetID,\n      ReactMount.getID(ancestorNode)\n    ) : invariant(false));\n  },\n\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  purgeID: purgeID\n};\n\n// Deprecations (remove for 0.13)\nReactMount.renderComponent = deprecated(\n  'ReactMount',\n  'renderComponent',\n  'render',\n  this,\n  ReactMount.render\n);\n\nmodule.exports = ReactMount;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}