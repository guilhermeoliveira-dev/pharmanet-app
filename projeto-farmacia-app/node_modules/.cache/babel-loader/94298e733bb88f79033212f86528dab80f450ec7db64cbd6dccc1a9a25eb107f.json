{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTransferer\n */\n\n\"use strict\";\n\nvar assign = require(\"./Object.assign\");\nvar emptyFunction = require(\"./emptyFunction\");\nvar invariant = require(\"./invariant\");\nvar joinClasses = require(\"./joinClasses\");\nvar warning = require(\"./warning\");\nvar didWarn = false;\n\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\nfunction createTransferStrategy(mergeStrategy) {\n  return function (props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\nvar transferStrategyMerge = createTransferStrategy(function (a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n    var transferStrategy = TransferStrategies[thisKey];\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n  return props;\n}\n\n/**\n * ReactPropTransferer are capable of transferring props to another component\n * using a `transferPropsTo` method.\n *\n * @class ReactPropTransferer\n */\nvar ReactPropTransferer = {\n  TransferStrategies: TransferStrategies,\n  /**\n   * Merge two props objects using TransferStrategies.\n   *\n   * @param {object} oldProps original props (they take precedence)\n   * @param {object} newProps new props to merge in\n   * @return {object} a new object containing both sets of props merged.\n   */\n  mergeProps: function (oldProps, newProps) {\n    return transferInto(assign({}, oldProps), newProps);\n  },\n  /**\n   * @lends {ReactPropTransferer.prototype}\n   */\n  Mixin: {\n    /**\n     * Transfer props from this component to a target component.\n     *\n     * Props that do not have an explicit transfer strategy will be transferred\n     * only if the target component does not already have the prop set.\n     *\n     * This is usually used to pass down props to a returned root component.\n     *\n     * @param {ReactElement} element Component receiving the properties.\n     * @return {ReactElement} The supplied `component`.\n     * @final\n     * @protected\n     */\n    transferPropsTo: function (element) {\n      \"production\" !== process.env.NODE_ENV ? invariant(element._owner === this, '%s: You can\\'t call transferPropsTo() on a component that you ' + 'don\\'t own, %s. This usually means you are calling ' + 'transferPropsTo() on a component passed in as props or children.', this.constructor.displayName, typeof element.type === 'string' ? element.type : element.type.displayName) : invariant(element._owner === this);\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (!didWarn) {\n          didWarn = true;\n          \"production\" !== process.env.NODE_ENV ? warning(false, 'transferPropsTo is deprecated. ' + 'See http://fb.me/react-transferpropsto for more information.') : null;\n        }\n      }\n\n      // Because elements are immutable we have to merge into the existing\n      // props object rather than clone it.\n      transferInto(element.props, this.props);\n      return element;\n    }\n  }\n};\nmodule.exports = ReactPropTransferer;","map":{"version":3,"names":["assign","require","emptyFunction","invariant","joinClasses","warning","didWarn","createTransferStrategy","mergeStrategy","props","key","value","hasOwnProperty","transferStrategyMerge","a","b","TransferStrategies","children","className","style","transferInto","newProps","thisKey","transferStrategy","ReactPropTransferer","mergeProps","oldProps","Mixin","transferPropsTo","element","process","env","NODE_ENV","_owner","constructor","displayName","type","module","exports"],"sources":["/home/guilherme/Faculdade/LP2/Projeto_Farmacia/projeto-farmacia-app/node_modules/react-checkbox/node_modules/react/lib/ReactPropTransferer.js"],"sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTransferer\n */\n\n\"use strict\";\n\nvar assign = require(\"./Object.assign\");\nvar emptyFunction = require(\"./emptyFunction\");\nvar invariant = require(\"./invariant\");\nvar joinClasses = require(\"./joinClasses\");\nvar warning = require(\"./warning\");\n\nvar didWarn = false;\n\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\nfunction createTransferStrategy(mergeStrategy) {\n  return function(props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\n\nvar transferStrategyMerge = createTransferStrategy(function(a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n\n    var transferStrategy = TransferStrategies[thisKey];\n\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n  return props;\n}\n\n/**\n * ReactPropTransferer are capable of transferring props to another component\n * using a `transferPropsTo` method.\n *\n * @class ReactPropTransferer\n */\nvar ReactPropTransferer = {\n\n  TransferStrategies: TransferStrategies,\n\n  /**\n   * Merge two props objects using TransferStrategies.\n   *\n   * @param {object} oldProps original props (they take precedence)\n   * @param {object} newProps new props to merge in\n   * @return {object} a new object containing both sets of props merged.\n   */\n  mergeProps: function(oldProps, newProps) {\n    return transferInto(assign({}, oldProps), newProps);\n  },\n\n  /**\n   * @lends {ReactPropTransferer.prototype}\n   */\n  Mixin: {\n\n    /**\n     * Transfer props from this component to a target component.\n     *\n     * Props that do not have an explicit transfer strategy will be transferred\n     * only if the target component does not already have the prop set.\n     *\n     * This is usually used to pass down props to a returned root component.\n     *\n     * @param {ReactElement} element Component receiving the properties.\n     * @return {ReactElement} The supplied `component`.\n     * @final\n     * @protected\n     */\n    transferPropsTo: function(element) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        element._owner === this,\n        '%s: You can\\'t call transferPropsTo() on a component that you ' +\n        'don\\'t own, %s. This usually means you are calling ' +\n        'transferPropsTo() on a component passed in as props or children.',\n        this.constructor.displayName,\n        typeof element.type === 'string' ?\n        element.type :\n        element.type.displayName\n      ) : invariant(element._owner === this));\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (!didWarn) {\n          didWarn = true;\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'transferPropsTo is deprecated. ' +\n            'See http://fb.me/react-transferpropsto for more information.'\n          ) : null);\n        }\n      }\n\n      // Because elements are immutable we have to merge into the existing\n      // props object rather than clone it.\n      transferInto(element.props, this.props);\n\n      return element;\n    }\n\n  }\n};\n\nmodule.exports = ReactPropTransferer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}